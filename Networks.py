from Utility.PriorityQueue import insert_tup
from math import ceil, floor, sqrt

from networkx import connected_watts_strogatz_graph, connected_caveman_graph, random_reference

def __initialize_vertice_population(config):
    vertices = []
    for _ in range(config.population_size // config.strands_per_cell):
        population = []
        for __ in range(config.strands_per_cell):
            strand = config.create_strand()
            population.append((config.fitness(strand), strand))
            insert_tup(population, strand, config.fitness(strand), config.strands_per_cell)

        vertices.append(population)

    return vertices

def empty(config):
    return __initialize_vertice_population(config), {}

def ring_lattice(config):
    vertices = __initialize_vertice_population(config)

    edges = {}
    for v in range(len(vertices)):
        edges[v] = ((v-1) % len(vertices), (v+1) % len(vertices))

    return vertices, edges

def cell(config):
    '''
    Cell structure is a grid where cells connect in the four cardinal directions
    (north, east, south, and west). We need to upscale the 1 dimensional vertices
    array to a matrix. We don't do this literally but we do create a mapping so 
    that we can build the edges. 

    First, we can find the most compact matrix representation. This is accomplished
    by taking the ceiling of the square root of the length of the vertices array. 
    This tells us the largest square matrix. It doesn't mean we will use all the
    space. 
    '''
    DIR = ((0,1), (0,-1), (1,0), (-1,0))

    vertices = __initialize_vertice_population(config)
    num_vertices = len(vertices)
    row_size = ceil(sqrt(num_vertices)) # row size and col size would be the same

    def index_to_coordinate(index):
        row = floor(index / row_size)
        col = index % row_size

        return row, col

    def coordinate_to_index(row, col):
        return row * row_size + col
    
    edges = {}
    for v in range(num_vertices):
        edges[v] = []
        v_row, v_col = index_to_coordinate(v)
        for direction in DIR:
            new_row, new_col = v_row + direction[0], v_col + direction[1]
            new_index = coordinate_to_index(new_row, new_col)
            if new_index < num_vertices:
                edges[v].append(new_index)

    return vertices, edges

def hier(config):
    '''
    This is also referred to as a master-slave parallel GA but I'm not going
    to call it that.
    '''
    vertices = __initialize_vertice_population(config)
    
    edges = {}
    edges[0] = [v for v in range(1, len(vertices))]
    for v in range(1, len(vertices)):
        edges[v] = [0]

    return vertices, edges

def __networkx_to_edges(G):
    edges = {}
    for edge in G.edges():
        if edge[0] not in edges:
            edges[edge[0]] = [edge[1]]
        else:
            edges[edge[0]].append(edge[1])

        if edge[1] not in edges:
            edges[edge[1]] = [edge[0]]
        else:
            edges[edge[1]].append(edge[0])

    return edges

def caveman(config):
    vertices = __initialize_vertice_population(config)

    # Note that the graphs generated by this only look right when there are 4 
    # members per a clique. The number of vertices divided by 4 should be 
    # be an integer else this will throw an exception
    assert (len(vertices) / 4).is_integer()
    G = connected_caveman_graph(int(len(vertices)/4), 4)

    return vertices, __networkx_to_edges(G)


def rewired_caveman(config):
    vertices = __initialize_vertice_population(config)

    # Note that the graphs generated by this only look right when there are 4 
    # members per a clique. The number of vertices divided by 4 should be 
    # be an integer else this will throw an exception
    assert (len(vertices) / 4).is_integer()
    G = connected_caveman_graph(int(len(vertices)/4), 4)

    return vertices, __networkx_to_edges(random_reference(G))

def watts_strogatz(config):
    vertices = __initialize_vertice_population(config)
    G = connected_watts_strogatz_graph(len(vertices), 4, 0.7)

    return vertices, __networkx_to_edges(random_reference(G))

NETWORKS = [
    ring_lattice,
    cell,
    hier,
    caveman,
    rewired_caveman
]